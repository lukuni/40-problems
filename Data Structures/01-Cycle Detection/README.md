## Бодлогын өгүүлбэр (Монгол)

Жагсаалтыг давах явцад аль нэг цэгт нэгээс олон удаа зочилсон бол холбогдсон жагсаалт нь цикл агуулна. Холбоостой жагсаалтын толгойд заагч өгөгдсөн бол энэ нь мөчлөг агуулсан эсэхийг тодорхойлно. Хэрэв тийм бол буцаж ирээрэй. Үгүй бол буцаана.
Жишээ 
зангилааны жагсаалтад хамаарна
Үзүүлсэн тоонууд нь өгөгдлийн утгууд биш харин зангилааны дугаарууд юм. Энэ жагсаалтад мөчлөг байхгүй тул буцна уу. 
зангилааны жагсаалтад хамаарна
3-р зангилаа 1-р цэг рүү буцах мөчлөг байдаг тул буцаана.
Функцийн тодорхойлолт
Доорх засварлагчийн has_cycle функцийг гүйцээнэ үү.
Энэ нь дараах параметртэй байна.
SinglyLinkedListNode заагч толгой: жагсаалтын толгойн ишлэл
Буцах
int: хэрэв мөчлөг байгаа бол эсвэл байхгүй бол
Жич: Жагсаалт хоосон байвал хоосон байна.
Оролтын формат
Кодын бүдүүвч нь stdin-ээс уншиж, тохирох аргументыг таны функцэд дамжуулдаг. Тестийн тохиолдлын хэлбэрийг нарийн төвөгтэй байдлаас шалтгаалан энэ асуултад тайлбарлахгүй. Хэрэв та захиалгат кейс хэрхэн үүсгэхийг мэдэхийг хүсвэл үндсэн функцийн хэсгийг өргөжүүлж, кодыг шалгана уу.
Хязгаарлалт

Жишээ оролт
Дараах холбогдсон жагсаалт бүрийн лавлагааг таны функцэд аргумент болгон дамжуулна:
Жишээ оролт
Жишээ гаралт
0
1
Тайлбар
Эхний жагсаалтад мөчлөг байхгүй тул буцаана уу.
Хоёрдахь жагсаалт нь мөчлөгтэй тул буцаана уу.




## Холбоос

https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem?isFullScreen=true




## Нотолгоо, тайлбар

*Асуудлын зорилго**

Өгөгдсөн `SinglyLinkedListNode head` буюу холбоост жагсаалтын эхлэлээс эхлэн гүйцэтгэхэд, тухайн холбоост жагсаалтад **мөргөлдсөн зангилаа (cycle)** буюу **ухраад буцаж очдог гогцоо байгаа эсэхийг шалгах** ёстой.

 Алгоритм: Floyd’s Cycle-Finding Algorithm (Тасалдуу ба түргэн заагч)**

Санаа**: Хоёр заагч (pointer) ашиглана:

  * `slow` — нэг нэгээр урагшилна
  * `fast` — хоёр хоёр урагшилна
* Хэрэв жагсаалтад цикл байгаа бол:

  * Түргэн (fast) заагч удаан (slow)-ыг гүйцэх болно.
* Хэрэв цикл байхгүй бол:

  * Түргэн заагч `null`-д хүрээд жагсаалтын төгсгөлд хүрнэ.

---

Нотолгоо

* `slow` ба `fast` хоёр нэгэн зэрэг жагсаалтаар урагш явна.
* Хэрвээ цикл байвал `fast` хэзээ нэгэн цагт `slow`-ыг гүйцэж заавал **адил байрлалд хүрнэ**.
* Жишээ нь, циклын урт `k` гэж үзвэл `fast` нь `slow`-оос 1 алхмаар түрүүлэн давтагдах боломж бүрддэг.
* Энэ нь `O(n)` хугацаанд илэрнэ (хамгийн ихдээ нэг бүтэн гогцоо тойрно).

Кодын тайлбар

```java
static boolean hasCycle(SinglyLinkedListNode head) {
    if (head == null) return false; // Хоосон жагсаалт бол циклгүй

    SinglyLinkedListNode slow = head;
    SinglyLinkedListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;         // нэг нэг алхам
        fast = fast.next.next;    // хоёр алхам

        if (slow == fast) {
            return true;          // Хоёр заагч таарсан = цикл байна
        }
    }

    return false; // fast эсвэл fast.next null болсон бол цикл байхгүй
}
```

| Шинж                                 | Үнэ цэнэ                            |
| ------------------------------------ | ----------------------------------- |
| Хугацааны нийлбэр (Time Complexity)  | `O(n)`                              |
| Санах ойн нийлбэр (Space Complexity) | `O(1)` (нэмэлт санах ой ашиглахгүй) |

---

 Жишээ

Жишээ 1:

**Input**: `1 -> 2 -> 3 -> null`
**Output**: `false` (цикл байхгүй)

 Жишээ 2:

**Input**: `1 -> 2 -> 3 -> 4` ба `4.next = 2`
**Output**: `true` 