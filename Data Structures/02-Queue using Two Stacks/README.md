## Бодлогын өгүүлбэр (Монгол)

Дараалал нь хийсвэр өгөгдлийн төрөл бөгөөд түүнд ямар элемент нэмсэн дарааллыг хадгалж, хамгийн эртний элементүүдийг урд талаас нь хасаж, ар талд нь шинэ элементүүдийг нэмж оруулах боломжийг олгодог. Дараалалд нэмсэн эхний элемент (жишээ нь, хамгийн удаан хүлээсэн элемент) үргэлж хамгийн түрүүнд хасагдах тул үүнийг "Эхлээд ирсэн" (FIFO) өгөгдлийн бүтэц гэж нэрлэдэг.
Үндсэн дараалал нь дараахь үйлдлүүдийг агуулна.
Дараалал: дарааллын төгсгөлд шинэ элемент нэмнэ.
Dequeue: дарааллын урд талын элементийг устгаад буцаана.
Энэ сорилтод та эхлээд хоёр стек ашиглан дараалал үүсгэх ёстой. Дараа нь асуулга бүр нь дараах төрлүүдийн аль нэг нь байх асуултуудыг боловсруул.
1 x: Элементийг дарааллын төгсгөлд оруулах.
2: Дарааллын урд талын элементийг дарааллын дагуу арилгана.
3: Дарааллын урд талын элементийг хэвлэнэ.
Оролтын формат
Эхний мөрөнд асуулгын тоог илэрхийлэх нэг бүхэл тоо байна.
Дараагийн мөрүүдийн мөр бүр дээрх асуудлын мэдэгдэлд тайлбарласан маягтын нэг хүсэлтийг агуулна. Гурван асуулга нь бүхэл тоогоор эхэлдэг боловч зөвхөн асуулгын дараа дараалалд оруулах утгыг илэрхийлэх зайгаар тусгаарлагдсан нэмэлт утгыг оруулна.
Хязгаарлалт



Төрөл бүрийн асуулгад хүчинтэй хариулт үргэлж байх нь баталгаатай.
Гаралтын формат
Төрөл бүрийн асуулгад дарааллын урд талын элементийн утгыг шинэ мөрөнд хэвлэнэ.
Жишээ оролт
STDIN функц
----- --------
10 q = 10 (асуулгын тоо)
1 42 1-р асуулга, дараалал 42
2 урд талын элемент
1 14 дараалал 42
3 урд талын элементийг хэвлэ
1 28 дараалал 28
3 урд талын элементийг хэвлэнэ
1 60 дараалал 60
1 78 дараалал 78
2 урд талын элемент
2 урд талын элемент
Жишээ гаралт
14
14
Тайлбар
Дараах үйлдлүүдийн дарааллыг гүйцэтгэнэ.
Дараалал; .
Дарааллын эхэнд байгаа утгыг эгнээнээс хасах, ; .
Дараалал; .
Дарааллын эхэнд байгаа утгыг хэвлэх, ; .
Дараалал; .
Дарааллын эхэнд байгаа утгыг хэвлэх, ; .
Дараалал; .
Дараалал; .
Дарааллын эхэнд байгаа утгыг эгнээнээс хасах, ; .
Дарааллын эхэнд байгаа утгыг эгнээнээс хасах, ; . java.io.* импортлох;
java.util.* импортлох;

нийтийн анги Шийдэл { 

public static void main(String[] args) { 
/* Энд кодоо оруулна уу. STDIN-ийн оролтыг уншина уу. STDOUT дээр хэвлэх гаралт. Танай анги Шийдэл нэртэй байх ёстой. */ 
}
}



## Холбоос

https://www.hackerrank.com/challenges/queue-using-two-stacks/problem?isFullScreen=true



## Нотолгоо, тайлбар

Мэдээж! Доор таны кодны гол ойлголт, шийдэл хэрхэн ажиллаж байгааг товч тайлбарлаж өгье.

Товч Нотолгоо ба Тайлбар

Асуудлын зорилго:

* Queue буюу Эхэлсэн дарааллаар (FIFO) өгөгдлийг хадгалах бүтэц хэрэгтэй.
* Гэтэл queue-г хоёр stack ашиглан хэрэгжүүлэх шаардлагатай.

Stack ба Queue ялгаа:

* Stack — Last In First Out (LIFO) буюу хамгийн сүүлд орсон элемент хамгийн түрүүн гарах бүтэц.
* Queue — First In First Out (FIFO) буюу хамгийн түрүүн орсон элемент хамгийн түрүүн гарах бүтэц.

Хэрхэн queue-г хоёр stack-аар хийх вэ?**

* `stack1` — шинэ элементүүдийг хадгалах (enqueue хийхэд ашиглана).
* `stack2` — dequeue буюу гарах элементүүдийг хадгална.

 Үйлдлүүдийн логик:

1. **Enqueue (1 x)**:
   `stack1` руу `x`-г хийх (push) — шинэ элементүүд бүгд `stack1` дээр байрлана.

2. **Dequeue (2)**:
   Хэрэв `stack2` хоосон бол:

   * `stack1`-ийн бүх элементүүдийг нэг нэгээр нь авч (`pop`), `stack2` руу хийдэг (`push`) — ингэснээр `stack2` дээр хамгийн эрт орсон элемент хамгийн дээд талд буюу хамгийн түрүүн гарах байдалд орно.
   * Дараа нь `stack2`-оос элемент (`pop`) хасна.

3. **Print Front (3)**:
   Хэрэв `stack2` хоосон бол дээрхтэй адил `stack1`-ээс `stack2` руу шилжүүлнэ.

   * Дараа нь `stack2`-ийн дээд элемент (`peek`) нь queue-н хамгийн түрүүн элемент буюу front-д байна. Түүнийг хэвлэнэ.


 Энэ арга ямар учраас зөв вэ?

* `stack1` дээр хадгалагдаж байгаа элементүүд сүүлд орсон учраас LIFO дарааллаар байна.
* `stack2` руу шилжүүлэхэд эрэмбэ өөрчлөгдөж, FIFO дарааллаар буцаж ордог.
* Ингэж хоёр stack-г хооронд нь ашигласнаар queue-г үр дүнтэй хэрэгжүүлж чадна.

 Амортизед (оролт дундаж) хугацаа:

* Нэг элемент `stack1`-д нэг удаа орж, дараа `stack2`-д нэг удаа ордог.
* Тиймээс нэг үйлдэл дунджаар O(1) хугацаанд хийгддэг.