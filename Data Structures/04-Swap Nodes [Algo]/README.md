## Бодлогын өгүүлбэр (Монгол)

Хоёртын мод нь дараах шинж чанаруудын аль нэгээр тодорхойлогддог мод юм.
Энэ нь хоосон байж болно (null).
Энэ нь зөвхөн эх зангилааг агуулдаг.
Энэ нь зүүн дэд мод, баруун дэд мод эсвэл хоёулангийнх нь үндсэн зангилааг агуулдаг. Эдгээр дэд моднууд нь бас хоёртын мод юм.
Дарааллаар дамжих ажлыг дараах байдлаар гүйцэтгэнэ
Зүүн дэд модыг тойруул.
Root руу зочилно уу.
Баруун талын дэд модыг гатлаарай.
Энэ дарааллаар дамжихын тулд үндсэн зангилааны зүүн хэсгээс эхэлж, навч хүрэх хүртлээ зүүн дэд модыг үргэлжлүүлэн судал. Навч дээр хүрэхдээ эцэг эх рүүгээ буцаж очоод зөв хүүхэд байгаа эсэхийг шалгаж, хэрэв байгаа бол очиж үзээрэй. Хэрэв хүүхэд байхгүй бол та түүний зүүн, баруун дэд модыг бүрэн судалсан байна. Хэрэв баруун хүүхэд байгаа бол түүний зүүн дэд модыг, дараа нь баруун талыг нь ижил аргаар гатлаарай. Модыг бүхэлд нь гатлах хүртлээ үүнийг хий. Дараах зүйлсийн аль нэг нь үнэн бол та зочлох үедээ зөвхөн зангилааны утгыг хадгалах болно.
Энэ нь зочилсон анхны зангилаа, анх удаа зочилсон цэг юм
Энэ бол навч, зөвхөн нэг удаа очиж үзэх ёстой
түүний бүх дэд модыг судалсан бөгөөд энэ нь үнэн бол зөвхөн нэг удаа зочлох ёстой
Энэ бол анх удаа зочилсон модны үндэс юм
Солих: Зангилааны дэд модыг солих гэдэг нь хэрэв зангилаа эхэндээ зүүн дэд мод L, баруун дэд мод R байсан бол сольсны дараа зүүн дэд мод R, баруун дэд мод L болно гэсэн үг.
Жишээлбэл, дараах модонд бид 1-р зангилааны хүүхдүүдийг сольж байна. 
Гүн 
1 1 [1] 
/ \ / \ 
2 3 -> 3 2 [2] 
\\\\ 
4 5 5 4 [3]
Зүүн модны дарааллаар 2 4 1 3 5, баруун модны 3 5 1 2 4 байна.
Солих ажиллагаа:
Бид зангилааны гүнийг дараах байдлаар тодорхойлно.
Үндэс зангилаа 1-р гүнд байна.
Хэрэв эх зангилааны гүн d бол одоогийн зангилааны гүн d+1 болно.
Нэг үйлдлээр мод болон бүхэл тоо өгөгдсөн k, h ∈ [k, 2k, 3k,...] гүнд байгаа бүх зангилааны дэд модыг солих шаардлагатай. Өөрөөр хэлбэл, h нь k-ийн үржвэр бол тухайн түвшний зүүн болон баруун дэд модыг солино.
Танд зангилаанууд нь [1..n]-аас индексжүүлсэн, 1-д үндэслэгдсэн n зангилаатай мод өгөгдсөн. Та түүн дээр t swap үйлдлүүдийг хийх ёстой бөгөөд своп үйлдэл бүрийн дараа модны одоогийн төлөвийн дарааллаар хөрвүүлгийг хэвлэнэ.
Функцийн тодорхойлолт
Доорх засварлагчийн swapNodes функцийг гүйцээнэ үү. Энэ нь хоёр хэмжээст массивыг буцаах ёстой бөгөөд элемент бүр нь своп үйлдлийн дараа дарааллаар дамжих зангилааны индексийг төлөөлөх бүхэл тоонуудын массив юм.
swapNodes нь дараах параметртэй байна:
- индексүүд: язгуур болгон эхний элементээр эхэлсэн , тус бүрийн индексийн утгыг илэрхийлэх бүхэл тоонуудын массив.
- асуулга: бүхэл тоонуудын массив, тус бүр нь утгыг илэрхийлдэг.
Оролтын формат
Эхний мөрөнд модны зангилааны тоо n-ийг агуулна.
Дараагийн n мөр бүр нь хоёр бүхэл тоо агуулсан a b бөгөөд a нь зүүн талын хүүхдийн индекс, b нь i-р зангилааны баруун хүүхдийн индекс юм.
Тайлбар: -1 нь хоосон цэгийг илэрхийлэхэд хэрэглэгддэг.
Дараагийн мөрөнд t-ийн хэмжээтэй бүхэл тоо байна.
Дараагийн t мөр бүр нь бүхэл тоо агуулсан бөгөөд тус бүр нь утга юм.
Гаралтын формат
k бүрийн хувьд своп үйлдлийг хийж, үр дүнгийн массив руугаа эрэмбэлсэн индексүүдийг хадгална. Бүх солилцох үйлдлүүдийг хийсний дараа үр дүнгийн массивыг хэвлэхээр буцаана уу.
Хязгаарлалт



Аль эсвэл
Аль эсвэл
Үгүй хүүхдийн индекс нь эцэг эхийнхээс үргэлж их байх болно.
Жишээ оролт 0
3
2 3
-1 -1
-1 -1
2
1
1
Жишээ гаралт 0
3 1 2
2 1 3
Тайлбар 0
2 ба 3-р зангилаа нь хүүхэдгүй тул солих нь тэдэнд ямар ч нөлөө үзүүлэхгүй. Бид зөвхөн эх зангилааны хүүхдийн зангилааг солих хэрэгтэй. 
1 [сек] 1 [сек] 1 
/ \ -> / \ -> / \ 
2 3 [с] 3 2 [с] 2 3
Тайлбар: [s] нь энэ гүнд своп үйлдэл хийгдэж байгааг харуулж байна.
Жишээ оролт 1
5
2 3
-1 4
-1 5
-1 -1
-1 -1
1
2
Жишээ гаралт 1
4 2 1 5 3
Тайлбар 1
2 ба 3-р зангилааны хүүхдийн зангилааг сольж бид олж авна 
1 1 
/ \ / \ 
2 3 [с] -> 2 3 
\ \ / / 
4 5 4 5
Жишээ оролт 2
11
2 3
4 -1
5 -1
6 -1
7 8
-1 9
-1 -1
10 11
-1 -1
-1 -1
-1 -1
2
2
4
Жишээ гаралт 2
2 9 6 4 1 3 7 5 11 8 10
2 6 9 4 1 3 7 5 10 8 11
Тайлбар 2
Энд бид 2 эсвэл 4-ийн гүнтэй зангилаанууд дээр, дараа нь 4-ийн гүнтэй зангилаанууд дээр солих үйлдлийг гүйцэтгэдэг. 
1 1 1 
/ \ / \ / \ 
/ \ / \ / \ 
2 3 [с] 2 3 2 3 
/ / \ \ \ \ 
/ / \ \ \ \ 
4 5 -> 4 5 -> 4 5 
/ / \ / / \ / / \ 
/ / \ / / \ /





## Холбоос

https://www.hackerrank.com/challenges/components-in-graph/problem?isFullScreen=true




## Нотолгоо, тайлбар

 Бодлогын үндсэн ойлголтууд:

*Өгөгдсөн мод нь бинар мод** (хүүхдүүд нь хамгийн их 2 ширхэг — зүүн, баруун).
*Гүн (depth):**

  * Үндэс (root) модны гүн 1.
  * Хүүхэд модны гүн = эцэг модны гүн + 1.

*Swap үйлдэл:**

  * Модны бүх зангилаануудыг гүн k-ийн олон дахин дээр (k, 2k, 3k, ...) хүүхдүүдийн байрлалыг солих буюу зүүн хүүхэд, баруун хүүхдийн байрлалыг солино.

*In-order traversal:**

  * Зүүн хүүхэд рүү орох
  * Одоогийн зангилааг хэвлэх
  * Баруун хүүхэд рүү орох

 Хэрхэн шийдэв?

1. **Модыг массив ашиглан илэрхийлэв:**

   * `left[i]` — i зангилааны зүүн хүүхэд
   * `right[i]` — i зангилааны баруун хүүхэд
   * -1 утга нь хүүхэд байхгүй гэсэн үг.

2. **Гүн тооцох:**

   * Үндсээс эхлэн өргөжүүлэн орж (`BFS` ашиглан) зангилаануудын гүнг `depth[i]` массиванд хадгалав.

3. **Swap үйлдлийг гүйцэтгэх:**

   * Өгөгдсөн k-ийн утгын хувьд гүн нь k-ийн олон дахин бүхий зангилаануудын зүүн, баруун хүүхдийг солино.

4. **In-order traversal хийх:**

   * Модыг эрэмбэлэн зүүн, үндэс, баруун гэсэн дарааллаар гаргана.

5. **Swap бүрийн дараа модыг in-order traversal-аар эрэмбэлж хэвлэх.**
 Гол санаа:

* `depth` ашиглаж ямар зангилаанд swap хийхийг тодорхойлно.
* `swap` үйлдэл нь тодорхой гүн дээрх зангилаануудын хүүхдүүдийн байрлалыг сольж байна.
* `in-order traversal` нь модыг эрэмбэлэх арга бөгөөд swap хийгдсэний дараах модны шинэ хэлбэрийг харахад ашиглагддаг.
