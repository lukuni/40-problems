## Бодлогын өгүүлбэр (Монгол)

Рон Гермиона хоёр хориотой ойн гүнд эмийн орц цуглуулж байгаа бөгөөд тэд замаа алдаж чадлаа. Ойгоос гарах зам хаагдсан тул тэднийг Хогвартс руу буцаах портын түлхүүр рүү явах ёстой.
Ойг сүлжээ гэж үзье. Нүд бүр хоосон (.-ээр төлөөлдөг) эсвэл модоор хаагдсан (төлөөлөгддөг). Рон, Гермиона хоёр хоосон нүднүүдийн дундуур ЗҮҮН, БАРУУН, ДЭЭШ, ДООШ (нэг үүр дотор хамтдаа) хөдөлж чаддаг ч модны нүдээр дамжин явж чадахгүй. Тэдний эхлэлийн нүдийг тэмдэгтээр, порт товчлуур бүхий нүдийг тэмдэгтээр тэмдэглэнэ. Зүүн дээд буланд индексжүүлсэн байна.
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......ХХХХ.
Дээрх жишээн дээр Рон Гермиона нар индекс дээр, порт түлхүүр нь -д байрладаг. Нүд бүрийг матрицын конвенцийн дагуу индексжүүлдэг.
Гермиона түлхүүрээ олоод явах цаг болсон гэж шийдэв. Тэд зам дагуу эхэлж, чиглэл сонгох болгондоо тэр саваагаа даллаж, зөв ​​чиглэлийг зааж өгдөг. Рон саваагаа яг хэдэн удаа даллах хэрэгтэй болно гэж бооцоо тавьж байна. Та Роны таамаг зөв эсэхийг тодорхойлж чадах уу?
Дээрх газрын зургийг дахин зурсан бөгөөд энэ нь эхлэх цэг (энэ тохиолдолд шийдвэр гарахгүй), шийдвэрийн цэгийг зааж өгсөн бөгөөд зам дээрх алхам юм:
.X.X.10000X
.X*0X0XXX0X
.XX0X0XM01.
...100XXXX.
Гермиона саваагаа ашиглах ёстой гурван тохиолдол байдаг.
Тайлбар: Эхлэх байршлаас портын товчлуур хүртэлх ганц зам байх нь баталгаатай.
Функцийн тодорхойлолт
Доорх засварлагчийн countLuck функцийг гүйцээнэ үү. Энэ нь Роны зөв эсвэл буруу бол мөрийг буцаах ёстой.
countLuck нь дараах параметрүүдийг агуулна.
матриц: мөрүүдийн жагсаалт, тус бүр нь матрицын мөрийг төлөөлдөг
k: Роны таамаглалыг илэрхийлэх бүхэл тоо
Оролтын формат
Эхний мөрөнд туршилтын тохиолдлын тоог бүхэл тоо агуулна.
Туршилтын тохиолдол бүрийг дараах байдлаар тайлбарлав.
Эхний мөрөнд зайгаар тусгаарлагдсан бүхэл тоонууд ба ойн матрицын мөр, баганын тоог агуулна.
Дараагийн мөр бүр нь ойн матрицын мөрийг дүрсэлсэн урттай мөрийг агуулна.
Сүүлийн мөрөнд Гермиона саваагаа хэдэн удаа даллахыг Роны таамагласан бүхэл тоо байна.
Хязгаарлалт



Ойд яг нэг, нэг байх болно.
болон хооронд яг нэг зам бий.
Гаралтын формат
Туршилтын тохиолдол бүрийн шинэ мөрөнд Рон зөв тааж Гермионагийн сэтгэлийг хөдөлгөж байвал хэвлэ. Үгүй бол хэвлэх.
Жишээ оролт
3
2 3
*.М
.X.
1
4 11
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......ХХХХ.
3
4 11
.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......ХХХХ.
4
Жишээ гаралт
сэтгэгдэл төрүүлсэн
сэтгэгдэл төрүүлсэн
Өө!
Тайлбар
Туршилтын тохиолдол бүрийн хувьд Гермиона саваагаа хэдэн удаа даллахыг илэрхийлнэ.
Тохиолдол 0: Гермиона саваагаа даллан бидэнд өгөв. Учир нь бид шинэ мөрөнд хэвлэнэ.
Тохиолдол 1: Гермиона шидэт саваагаа , , болон , бидэнд өгөв. Учир нь бид шинэ мөрөнд хэвлэнэ.
Тохиолдол 2: Гермиона шидэт саваагаа , , болон , бидэнд өгөв. Учир нь ба , мөн бид шинэ мөрөнд хэвлэнэ.



## Холбоос

https://www.hackerrank.com/challenges/count-luck/problem?isFullScreen=true


## Нотолгоо, тайлбар


# **Асуудлын тойм**

* Ron ба Hermione хоёр **2D сүлжээ (grid)** дээр эхлэн нэг цэгээс (`M`) порткийн байр (`*`) руу явах зам хайж байна.
* Зам дээрх `X` нь модтой зай буюу явж болохгүй.
* `.` нь чөлөөт зай.
* Hermione зам дээр явж байхдаа ямар чиглэл сонгохдоо хэр удаа сонголт хийх хэрэгтэйг тоолно (decision points).
* Decision point гэдэг нь тухайн байрлалд дараагийн алхамд 2 буюу түүнээс дээш боломжит зам байвал тооцдог.
* Ron-ийн таамагласан decision count `k`-тай үнэн эсэхийг шалгах.

---

# **Гол санаа**

## 1. DFS ашиглан замыг хайх

* Эхлэн (`M`) цэгээс порткийн (`*`) цэг хүртэл DFS (Depth-First Search) хийнэ.
* Явах боломжтой бүх 4 чиглэл рүү туршиж үзнэ.
* `visited` массив ашиглаж давтан очихоос сэргийлнэ.

## 2. Decision point тоолох

* Өөрийн одоогийн байрлалд явах боломжтой шинэ (шийдэгдээгүй) хашаа (`.` эсвэл `*`) 2 ба түүнээс дээш байвал decision point.
* Decision point дээр Hermione wand-аа ашиглана → count++ хийнэ.

## 3. Эцсийн үр дүнг Ron-ийн таамагтай харьцуулах

* Хэрвээ бодит decision point-уудын тоо Ron-ийн таамагтай адил бол `Impressed` хэвлэнэ.
* Үгүй бол `Oops!`.

---

# **Кодын тайлбар**

```java
static int dfs(char[][] grid, boolean[][] visited, int x, int y, int count) {
    // Хэрэв порткийн байрлалд ирсэн бол одоогийн count-ийг буцаана.
    if (grid[x][y] == '*') return count;

    visited[x][y] = true; // Одоо энэ байрлалыг очсон гэж тэмдэглэе.

    List<int[]> options = new ArrayList<>();
    // Хажууд байгаа 4 талын боломжит замуудыг хайна
    for (int d = 0; d < 4; d++) {
        int nx = x + dx[d];
        int ny = y + dy[d];

        if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length &&
            grid[nx][ny] != 'X' && !visited[nx][ny]) {
            options.add(new int[]{nx, ny});
        }
    }

    // Хэрэв 2 буюу түүнээс дээш боломж байвал decision point
    if (options.size() > 1) count++;

    // Боломж тус бүр дээр дахин DFS-г ажиллуулж порткийн байрлалд хүрэх замыг хайна
    for (int[] opt : options) {
        int result = dfs(grid, visited, opt[0], opt[1], count);
        if (result != -1) return result; // Зам олдсон бол үр дүнг буцаана
    }

    return -1; // Зам олдсонгүй тохиолдолд
}
```

---

# **Нотолгоо**

* DFS нь бүх боломжит замыг судалж ганц зам байгаа гэдэг нөхцөлд амжилттай эцсийн байрлалыг олдог.
* Decision point-д хэдэн сонголт байгаагаар `count` нэмэгдэнэ.
* Явах боломжгүй замуудыг орхиж, өмнө очсон газруудаа дахиж оролдохгүй байхаар `visited` ашиглана.
* Нэг замтай (unique path) тул үр дүн баталгаатай.

---

# **Дүгнэлт**

* Хэрвээ таны тоолсон decision point-ийн тоо Ron-ийн таамагтай тохирч байвал `"Impressed"` гэж хэвлэнэ.
* Үгүй бол `"Oops!"`.
