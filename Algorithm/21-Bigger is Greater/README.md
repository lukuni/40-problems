## Бодлогын өгүүлбэр (Монгол)


Мөртэй харьцахдаа үг зүйн дарааллыг ихэвчлэн цагаан толгойн дараалал гэж нэрлэдэг. Хэрэв үг хэллэгээр эрэмбэлэгдсэн жагсаалтад дараа орж ирвэл тэмдэгт мөр нь өөр тэмдэгт мөрөөс их байна.

Нэг үг өгөгдсөн бол зарим эсвэл бүх тэмдэгтийг нь сольж шинэ үг үүсгэ. Энэ шинэ үг нь хоёр шалгуурыг хангасан байх ёстой:

Энэ нь анхны үгнээс илүү байх ёстой
Энэ нь эхний нөхцөлийг хангасан хамгийн жижиг үг байх ёстой
Жишээ

Дараагийн том үг бол .

Доорх biggerIsGreater функцийг гүйцээж, шалгуурт нийцсэн шинэ мөр үүсгэж, буцаана уу. Хэрэв боломжгүй бол хариу өгөхгүй.

Функцийн тодорхойлолт

Доорх засварлагчийн biggerIsGreater функцийг гүйцээнэ үү.

biggerIsGreater дараах параметртэй байна:

w мөр: үг
Буцах
- тэмдэгт мөр: Үг зүйн хувьд хамгийн бага байх боломжтой эсвэл хариулт байхгүй

Оролтын формат

Оролтын эхний мөрөнд туршилтын тохиолдлын тоог агуулна.
Дараагийн мөр бүрийг агуулна.

Хязгаарлалт

ascii[a..z] муж дахь зөвхөн үсгүүдийг агуулна.
Жишээ оролт 0

5
ab
bb
hefg
dhck
dkhc
Жишээ гаралт 0

ба
хариулт алга
hegf
dhkc
hcdk
Тайлбар 0

Туршилтын тохиолдол 1:
ba нь ab-г дахин цэгцлэх замаар хийж болох цорын ганц тэмдэгт мөр юм. Энэ нь илүү том юм.
Туршилтын тохиолдол 2:
bb-г дахин цэгцэлж, илүү том мөр авах боломжгүй.
Туршилтын тохиолдол 3:
hegf нь hefg-ээс том дараагийн мөр юм.
Туршилтын тохиолдол 4:
dhkc нь dhck-ээс том дараагийн мөр юм.
Туршилтын тохиолдол 5:
hcdk нь dkhc-ээс том дараагийн мөр юм.
Жишээ оролт 1

6
үгүй ээ
dcba
dcbb
abdc
abcd
fedcbabcd
Жишээ гаралт 1

лимон
хариулт алга
хариулт алга
acbd
abdc
fedcbabdc.




## Холбоос

https://www.hackerrank.com/challenges/bigger-is-greater/problem?isFullScreen=true




## Нотолгоо, тайлбар

biggerIsGreater Функцийн Тайлбар

 Зорилго

Өгөгдсөн үгний (string) дараагийн хамгийн бага бөгөөд үүнээс том хувилбарыг ол. Хэрэв боломжгүй бол "no answer" буцаана.

⚙️ Алгоритмын алхмууд

Баруун талаас урагш эрэмбэлэл алдагдсан цэгийг олно (pivot):

Хамгийн баруун талаас эхэлж, chars[i] < chars[i+1] байх хамгийн сүүлийн i индексийг хайна.

Энэ нь "даваа" буюу өгөгдсөн үгийн хамгийн сүүлийн "өргөгдсөн" хэсэг юм.

Pivot-аас баруун талд түүнээс том хамгийн бага үсгийг хайна:

Энэ нь солилт хийх (swap) хамгийн тохиромжтой цэг.

Солилт хийх:

chars[i] болон chars[j] хоёрын утгыг солино.

Pivot-аас хойших хэсгийг эргүүлж эрэмбэлнэ (reverse):

Учир нь энэ хэсгийг хамгийн бага утгатайгаар хийх шаардлагатай.

 Жишээ

Input:
dkhc

Алгоритм ажиллах дараалал:

i = 2 (h < c биш)

i = 1 (k < h биш)

i = 0 (d < k) → Pivot олдлоо.

j = 3 (c > d) → Солих үсэг олдлоо.

d болон c-г соль → ckhd

khd-г эргүүлж hdk → chdk

Output:
hcdk

 Жишээ Гаралт

Оролт	Гаралт
ab	ba
bb	no answer
hefg	hegf
dhck	dhkc
dkhc	hcdk

 Цаг хугацааны нийлэмж (Time Complexity)

Алгоритм: O(n), нэг удаа зүүнээс баруун, дараа нь баруунаас зүүн тийш гүйцэтгэнэ.

Хамгийн уртдаа гурван шугаман алхамтай.