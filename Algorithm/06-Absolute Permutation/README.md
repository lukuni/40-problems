## Бодлогын өгүүлбэр (Монгол)
Бид муж дахь анхны натурал тоонуудын орлуулалт гэж тодорхойлсон. Сэлгээний байрлал дахь утгыг -based индексжүүлэлтийг ашиглан тэмдэглэе. 
бүрт үнэн байвал үнэмлэхүй орлуулалт гэж үзнэ.
Өгөгдсөн ба , үг зүйн хувьд хамгийн бага үнэмлэхүй орлуулахыг хэвлэ. Үнэмлэхүй орлуулалт байхгүй бол -1 гэж хэвлэ.
Жишээ


-аас , хүртэлх элементүүдийн массив үүсгэ. Үндэслэсэн индексжүүлэлтийг ашиглан сэлгэн залгалт үүсгэнэ үү. Үүнийг бүх үнэмлэхүй зөрүүтэй тэнцүү байхаар дахин зохион байгуулж болно:
pos[i] i |pos[i] - i| 
3 1 2 
4 2 2 
1 3 2 
2 4 2
Функцийн тодорхойлолт
Доорх засварлагчийн үнэмлэхүйPermutation функцийг гүйцээнэ үү.
absolyutPermutation нь дараах параметртэй байна:
int n: харгалзан үзэх натурал тоонуудын дээд хязгаар
int k: элемент бүрийн утга ба индексийн хоорондох үнэмлэхүй зөрүү
Буцах
int[n]: үг зүйн хувьд хамгийн бага орлуулалт, эсвэл байхгүй бол
Оролтын формат
Эхний мөрөнд бүхэл тоо, асуулгын тоог агуулна.
Дараагийн мөр бүр нь зайгаар тусгаарлагдсан бүхэл тоонуудыг агуулдаг ба .
Хязгаарлалт



Жишээ оролт
STDIN функц
----- --------
3 t = 3 (асуулгын тоо)
2 1 n = 2, k = 1
3 0 n = 3, k = 0
3 2 n = 3, k = 2
Жишээ гаралт
2 1
1 2 3
-1
Тайлбар
Туршилтын тохиолдол 0:



## Холбоос
https://www.hackerrank.com/challenges/absolute-permutation/problem?isFullScreen=true



## Нотолгоо, тайлбар

Бодлогын нэр: Absolute Permutation

Бодлогын тайлбар
n хүртэлх бүхэл тоонуудын эрэмбэлэлтээс |pos[i] - i| = k байх хамгийн жижиг лексикографийн эрэмбэлэлтийг олох.

Алгоритмын танилцуулга болон нотолгоо
Үндсэн санаа
Бодлогын нөхцөлөөс үзвэл индекс болон элементийн утгын зөрүү заавал k байх ёстой.
Энэ нь эрэмбэлэлтийг хэсэг хэсгээр (блок) хуваах боломжийг олгодог.
k нэмэх ба k хасах үйлдлийг ээлжлэн давтан хийх нь хамгийн жижиг эрэмбэлэлтийг үүсгэнэ.
Шаардлагатай нөхцөл
Хэрэв k == 0 бол эрэмбэлэлт өөрчлөгдөхгүй учир [1, 2, ..., n] дараалал шууд боломжтой.
n нь 2*k-р хуваагдахгүй бол ийм эрэмбэлэлт боломжгүй тул -1 буцаана.
Нотолгоо
Хэрэв n % (2*k) != 0, тодорхой блокууд бүрэн бүтэн үүсэхгүй тул зарим элементүүдийн зөрүүг k болгох боломжгүй. Иймд шийдэл үгүй болно.
Харин n % (2*k) == 0 бол n/(2*k) тооны блок үүснэ. Блок бүрд k нэмэх болон k хасах үйлдлийг ээлжлэн хийхэд бүх i-ийн хувьд |pos[i] - i| = k хангагдана.
Энэ арга нь хамгийн жижиг лексикографийн дарааллыг гаргана учир шийдэл баталгаатай.
Жишээ
n=4, k=2
Эрэмбэлэлт: [3,4,1,2]
Тайлбар:
|3-1|=2, |4-2|=2, |1-3|=2, |2-4|=2


